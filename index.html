<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>rainyleo blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="rainyleo blog">
<meta property="og:url" content="http://www.rainyleo.com/index.html">
<meta property="og:site_name" content="rainyleo blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="rainyleo blog">
  
    <link rel="alternate" href="/atom.xml" title="rainyleo blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> -->
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rainyleo blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.rainyleo.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-webpack-code-split" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/21/webpack-code-split/" class="article-date">
  <time datetime="2017-01-21T03:35:50.000Z" itemprop="datePublished">2017-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/21/webpack-code-split/">webpack 中使用 code splitting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>代码分割(Code splitting)是 webpack 最强大的特性之一. 它让你可以把代码分割到不同的 bundle 中之后你可以按需加载-例如当用户导航到一个匹配的路由, 或触发一个事件. 这会产生更小的 bundle, 还可以控制资源加载的优先级. 如果正确使用的话, 会对应用的加载时间产生很好的优化</p>
<p>webpack 中主要有2中类型的 code splitting</p>
<h2 id="资源-splitting-用于缓存和并行加载"><a href="#资源-splitting-用于缓存和并行加载" class="headerlink" title="资源 splitting 用于缓存和并行加载"></a>资源 splitting 用于缓存和并行加载</h2><h3 id="第三方库-code-splitting"><a href="#第三方库-code-splitting" class="headerlink" title="第三方库 code splitting"></a>第三方库 code splitting</h3><p>应用中经常会依赖许多第三方库, 和应用代码不同,这些第三方库的代码很少有改动</p>
<p>如果把这些库中的代码打包的单独的 bundle 中, 可以利用浏览器的缓存机制更长时间的缓存这些文件.</p>
<p>要想这样做, 文件名中的 <code>[hash]</code> 部分不论应用代码如何变化都需要保存不变. 需要和<code>CommonsChunkPlugin</code> 插件一起使用.</p>
<h3 id="CSS-splitting"><a href="#CSS-splitting" class="headerlink" title="CSS splitting"></a>CSS splitting</h3><p>也可以把样式分离到单独的 bundle 中, 独立于应用逻辑. 这样有利于样式文件的缓存, 而且可以让浏览器并行加载应用代码和样式文件, 避免出现 FOUC(flash of unstyled content, 无样式内容闪现)</p>
<p>需要配合<code>extract-text-webpack-plugin</code> 一起使用.<br>
        
          <p class="article-more-link">
            <a href="/2017/01/21/webpack-code-split/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2017/01/21/webpack-code-split/" data-id="cjd8gh7ld00101o1njrchac5y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue-源码解读-模板编译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/26/Vue-源码解读-模板编译/" class="article-date">
  <time datetime="2016-12-26T07:44:10.000Z" itemprop="datePublished">2016-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/26/Vue-源码解读-模板编译/">Vue 源码解读-模板编译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看一下代码目录:</p>
<ul>
<li><p><strong><code>src</code></strong>: 源码目录. 代码用 ES2015 编写, 使用 <a href="https://flowtype.org/" target="_blank" rel="external">Flow</a> 做类型注释.</p>
<ul>
<li><p><strong><code>entries</code></strong>: 不同 builds 和 packages 的入口.</p>
<ul>
<li><p><strong><code>web-runtime.js</code></strong>: <code>dist/vue.common.js</code> 的入口, 也就是 runtime-only build. 不包含 template to render function compiler, 因此不支持 <code>template</code> 选项. <strong>它在 <code>package.json</code> 被设为 <code>main</code> field, 当你从 NPM package 中 import Vue 时, 它是默认的输出.</strong></p>
</li>
<li><p><strong><code>web-runtime-with-compiler.js</code></strong>: <code>dist/vue.js</code> 的入口, 也就是 standalone build. 它包含了 template to render function compiler. 如果想要从 NPM packages 中使用的话, 要 <code>import Vue from &#39;vue/dist/vue&#39;</code>, 或者 在构建工具的配置中 alias <code>vue</code> to <code>vue/dist/vue</code> .</p>
</li>
<li><p><strong><code>web-compiler.js</code></strong>: <code>vue-template-compiler</code> NPM package 的入口.</p>
</li>
<li><p><strong><code>web-server-renderer.js</code></strong>: <code>vue-server-renderer</code> NPM package 的入口.</p>
</li>
</ul>
</li>
<li><p><strong><code>compiler</code></strong>: 包含 template-to-render-function compiler 的代码.</p>
<p>compiler 包含 parser (把 template strings 转为 element ASTs), optimizer (检查 static trees for vdom render 优化), code generator (从 element ASTs 生成 render function code ). 注意到 codegen 直接从 element AST 生成 code strings - 这样为了减小代码体积,  因为在 standalone build 里 compiler 会加载到浏览器.</p>
</li>
<li><p><strong><code>core</code></strong>: 包含通用的, 与平台无关的 runtime code.</p>
<p><code>core</code> 里的代码可以再任意的 JavaScript 环境中运行, 例如 browser, Node.js, 或 an embedded JavaScript runtime in native applications.</p>
<ul>
<li><p><strong><code>observer</code></strong>: 包含和响应式系统相关的代码.</p>
</li>
<li><p><strong><code>vdom</code></strong>: 包含 vdom element creation and patching 的代码.</p>
</li>
<li><p><strong><code>instance</code></strong>: 包含 Vue 实例构造函数和原型方法.</p>
</li>
<li><p><strong><code>global-api</code></strong>: 如名称所示.</p>
</li>
<li><p><strong><code>components</code></strong>: 通用的抽象组件. 目前 <code>keep-alive</code> 是唯一的一个.</p>
</li>
</ul>
</li>
<li><p><strong><code>server</code></strong>: 包含 server-side 渲染相关的代码.</p>
</li>
<li><p><strong><code>platforms</code></strong>: 包含平台相关的代码.</p>
<p>每个平台模块包含三个部分: <code>compiler</code>, <code>runtime</code> and <code>server</code>, 和上面的三个目录相一致. 每一部分包含平台相关的 模块/工具, 会被导入到平台相关的入口文件中. 例如, 实现 <code>v-bind:class</code> 逻辑的代码位于 <code>platforms/web/runtime/modules/class.js</code> - 会在 <code>entries/web-runtime.js</code> 中导入, 它用来创建浏览器相关的 vdom patching function.</p>
</li>
<li><p><strong><code>sfc</code></strong>: 包含单文件组件 (<code>*.vue</code> files) parsing logic. 这用在 <code>vue-template-compiler</code> package.</p>
</li>
<li><p><strong><code>shared</code></strong>: 整个代码中公用的工具函数.</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/12/26/Vue-源码解读-模板编译/" data-id="cjd8gh7l0000l1o1n9fy6e49y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Vue-源码解读1-响应式系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/Vue-源码解读1-响应式系统/" class="article-date">
  <time datetime="2016-12-14T16:43:04.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/Vue-源码解读1-响应式系统/">Vue 源码解读-响应式系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Vue 的核心之一就是它的响应式系统, model 只是普通的 JavaScript 对象, 当修改它时, view 会进行更新. 当把一个对象作为 <code>data</code> 属性传入 Vue 的实例中时, Vue 会遍历它上面的属性, 并用 <code>Object.defineProperty</code> 把它们转为 getter/setter, 以进行依赖追踪和通知更改. Vue 实现响应式的原理代码位于 <code>src/core/observer</code>, 目录结构如下, 以下基于 Vue 2.1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">├── observer</div><div class="line">  ├── array.js</div><div class="line">  ├── dep.js</div><div class="line">  ├── index.js</div><div class="line">  ├── scheduler.js</div><div class="line">  └── watcher.js</div></pre></td></tr></table></figure>
<p>Vue 内部实现响应式时使用了 <code>发布-订阅</code> 的设计模式, 主要内容为 3 大块: Observer, Watcher, Dep. Observer 使 data 上的数据成为发布者, 而指令(包括模板指令, computed, $watch 内的属性)对应的 watcher 则为订阅者, Dep 的作用主要在于维护订阅者数组, 当数据变化时通知订阅者进行更新.</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer 给 data 上的数据设置 getter/setter. 当设置 getter 时, 进行’依赖收集(订阅)’过程, 当 setter 触发时, 进行’通知更新(发布)’的过程.</p>
<p>源码如下:</p>
        
          <p class="article-more-link">
            <a href="/2016/12/15/Vue-源码解读1-响应式系统/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/12/15/Vue-源码解读1-响应式系统/" data-id="cjd8gh7l3000o1o1nnlsggznb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redux源码解读(5)-applyMiddleware" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/Redux源码解读(5)-applyMiddleware/" class="article-date">
  <time datetime="2016-11-01T09:48:51.000Z" itemprop="datePublished">2016-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/Redux源码解读(5)-applyMiddleware/">Redux源码解读(5)-applyMiddleware</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>applyMiddleware()</code>感觉应该是redux的5个API中最绕人一个了, 它往往作为<code>createStore()</code>的第三个参数<code>enhancer</code>, 那它<code>enhance</code>了什么呢? 答案就是<code>createStore()</code>里面的<code>dispatch</code>函数</p>
<ul>
<li><p>函数参数, 参数为包含几个不同<code>middleware</code>的数组或只有一个middleware函数,<br>每个<code>middleware</code>函数会返回一个接收3次参数的柯里化函数, 它有这样的语句<code>return ({ dispatch, getState }) =&gt; next =&gt; action =&gt;</code>, 见最下面的thunk-middleware</p>
</li>
<li><p>返回值, 返回一个接收2次参数的函数   </p>
</li>
</ul>
<p>要把<code>applyMiddleware()</code>理解清楚, 需要联系<code>createStore()</code>, 它们会相互调用, 下面两处代码要结合起来看</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2>
        
          <p class="article-more-link">
            <a href="/2016/11/01/Redux源码解读(5)-applyMiddleware/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/11/01/Redux源码解读(5)-applyMiddleware/" data-id="cjd8gh7l9000t1o1ngzthmbdr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redux源码解读(4)-compose" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/30/Redux源码解读(4)-compose/" class="article-date">
  <time datetime="2016-10-30T12:52:01.000Z" itemprop="datePublished">2016-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/30/Redux源码解读(4)-compose/">Redux源码解读(4)-compose</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>compose这个函数在函数式编程中很常见, 它把一个函数函数的结果传进另一个函数中, 例如<code>compose(f, g, h)(x)</code> 返回 <code>f(g(h(x)))</code></p>
<p>下面先看一个简化版本的compose以便理解   </p>
<pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g</span>) </span>{
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> f.call(<span class="keyword">this</span>, g.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));
  };
  <span class="comment">/* 如果只接收一个参数, 也可以这样写
  return function(x) {
    return f(g(x));
  };
  */</span>
}  

<span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;
<span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;
<span class="keyword">const</span> res = compose(square, sum);
res(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 25</span>
</code></pre>
        
          <p class="article-more-link">
            <a href="/2016/10/30/Redux源码解读(4)-compose/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/10/30/Redux源码解读(4)-compose/" data-id="cjd8gh7ky000j1o1ne4yttvh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redux源码解读(3)-bindActionCreators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/29/Redux源码解读(3)-bindActionCreators/" class="article-date">
  <time datetime="2016-10-29T09:52:01.000Z" itemprop="datePublished">2016-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/29/Redux源码解读(3)-bindActionCreators/">Redux源码解读(3)-bindActionCreators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>函数参数, <code>bindActionCreators</code>接收2个参数, <code>actionCreators</code>和<code>dispatch</code>,<br><code>actionCreators</code>可以是一个函数, 也可以是包含几个函数的对象  </p>
</li>
<li><p>返回值, 返回值对应<code>actionCreators</code>这个参数, 当它是函数时, 返回值是一个函数, 这个返回的函数接收一个参数传入<code>actionCreator</code>得到 <code>action</code>, 再调用<code>dispatch</code>; 当它是包含几个函数的对象时, 返回值为包含这几个函数调用结果的对象</p>
</li>
</ul>
<p><code>bindActionCreators()</code> 是函数式编程中的组合函数<code>compose</code>,  在下一篇的compose中会提到, 组合函数形如<br><code>compose(f, g)(...args) --&gt; g(f(...args))</code>, 在这里<code>f</code>和<code>g</code>分别为参数<code>actionCreator</code>和<code>dispatch</code> </p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2>
        
          <p class="article-more-link">
            <a href="/2016/10/29/Redux源码解读(3)-bindActionCreators/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/10/29/Redux源码解读(3)-bindActionCreators/" data-id="cjd8gh7kw000h1o1np9yyh41f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redux源码解读(2)-combineReducers" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/29/Redux源码解读(2)-combineReducers/" class="article-date">
  <time datetime="2016-10-29T00:27:31.000Z" itemprop="datePublished">2016-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/29/Redux源码解读(2)-combineReducers/">Redux源码解读(2)-combineReducers</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>函数参数, 接收一个包含几个不同reducer函数的对象 </li>
<li>返回值, 返回一个合并的reducer.   </li>
</ul>
<p>当这个合并的<code>reducer</code>接收到<code>action</code>时, 会调用每一个子<code>reducer</code>, 把它们的结果放到一个<code>state</code>对象中, state 对象的属性对应各自 reducer 中的 state </p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2>
        
          <p class="article-more-link">
            <a href="/2016/10/29/Redux源码解读(2)-combineReducers/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/10/29/Redux源码解读(2)-combineReducers/" data-id="cjd8gh7ks000f1o1nclkl5st3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redux源码解读(1)-createStore" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/28/Redux源码解读(1)-createStore/" class="article-date">
  <time datetime="2016-10-28T11:51:59.000Z" itemprop="datePublished">2016-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/28/Redux源码解读(1)-createStore/">Redux源码解读(1)-createStore</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redux一共有5个公共方法, 先说第一个<code>createStore()</code>  </p>
<ul>
<li>函数参数, 可以接收3个参数, <code>reducer</code>, <code>preloadedState</code>, <code>enhancer</code>, 后两个是可选的</li>
<li><p>返回值, 返回一个object, 它包含4个公有方法, 分别为<code>getStore()</code>, <code>subscribe(listener)</code>, <code>dispatch(action)</code>, <code>replaceReducer(nextReducer)</code>  </p>
<p>createStore函数使用了设计模式中的暴露模块模式(Revealing Module Pattern)</p>
</li>
</ul>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2>
        
          <p class="article-more-link">
            <a href="/2016/10/28/Redux源码解读(1)-createStore/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/10/28/Redux源码解读(1)-createStore/" data-id="cjd8gh7kn000c1o1nm5xmnzzq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-flex-layout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/26/flex-layout/" class="article-date">
  <time datetime="2016-10-26T03:28:48.000Z" itemprop="datePublished">2016-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/26/flex-layout/">flex layout</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Flex-盒模型和术语"><a href="#Flex-盒模型和术语" class="headerlink" title="Flex 盒模型和术语"></a>Flex 盒模型和术语</h2><p>Flex is a CSS box model optimized for user interface design. In the flex layout model, the children of a flex container can be laid out in any direction, and can “flex” their sizes, either growing to fill unused space or shrinking to avoid overflowing the parent. Both horizontal and vertical alignment of the children can be easily manipulated. Nesting of these boxes (horizontal inside vertical, or vertical inside horizontal) can be used to build layouts in two dimensions.</p>
<p>The flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based).</p>
<ul>
<li>flex container: 元素的 display 属性为 flex 或 inline-flex. 文档流中 flex container 的子元素叫做 flex items, 它们以 flex layout model 进行布局.</li>
<li>flex item:</li>
<li>main axis</li>
<li>cross axis</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2016/10/26/flex-layout/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/10/26/flex-layout/" data-id="cjd8gh7lb000v1o1nr0cdg5d4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React-component-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/14/React-component-pattern/" class="article-date">
  <time datetime="2016-10-14T02:51:08.000Z" itemprop="datePublished">2016-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/14/React-component-pattern/">React中的组件分类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.z97goyfuy">原文链接</a></p>
<p>React 中一切都是组件化的, 把组件分为2种类型有利于开发和重用. 可以把这两种类型称为<em>容器组件(Container component)</em> 和 <em>呈现组件(Presentational component)</em>.  </p>
<p>它们有什么区别呢?  </p>
<p><strong>呈现组件</strong>的特点:  </p>
<ul>
<li>关注UI的展现</li>
<li>可以在内部包含呈现和容器组件, 通常有一些DOM标签和自己的样式</li>
<li>仅从<code>props</code>接收数据和回调  </li>
<li>通常没有自己的<code>state</code></li>
<li>通常可以写成函数组件, 除非需要 state 或生命周期函数</li>
<li>和应用中其他部分没有关联, 比如 Redux</li>
<li>不关心数据是怎样传递和修改的</li>
<li>可以有<code>this.props.children</code></li>
<li>通常是手写的</li>
<li>例如: <em>Page, Sidebar, Story, UserInfo, List</em></li>
</ul>
        
          <p class="article-more-link">
            <a href="/2016/10/14/React-component-pattern/#more">阅读更多</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.rainyleo.com/2016/10/14/React-component-pattern/" data-id="cjd8gh7kl000a1o1nnwftfy2z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/React/" style="font-size: 16.67px;">React</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/atom/" style="font-size: 10px;">atom</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/21/webpack-code-split/">webpack 中使用 code splitting</a>
          </li>
        
          <li>
            <a href="/2016/12/26/Vue-源码解读-模板编译/">Vue 源码解读-模板编译</a>
          </li>
        
          <li>
            <a href="/2016/12/15/Vue-源码解读1-响应式系统/">Vue 源码解读-响应式系统</a>
          </li>
        
          <li>
            <a href="/2016/11/01/Redux源码解读(5)-applyMiddleware/">Redux源码解读(5)-applyMiddleware</a>
          </li>
        
          <li>
            <a href="/2016/10/30/Redux源码解读(4)-compose/">Redux源码解读(4)-compose</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 rainyLeo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

<div id="totop" style="position:fixed;bottom:120px;right:50px;cursor: pointer;">
	<a title="返回顶部"><img src="/images/scrollup.png" /></a>
</div>
<script src="/js/totop.js"></script>
<!-- to top -->
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    



<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>




  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>